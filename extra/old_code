H = np.matrix('1 1; 1 -1')*(1/math.sqrt(2))

def classical_circuit(INIT):
    result = (Z*X*H*INIT*H*X).trace()
    print(result)

def circuit(INIT):
    results = []
    samples = 10000
    for i in range(0,samples):
        # pick a pauli for INIT
        r1 = pick_pauli(INIT)
        STATE = r1[0]

        STATE = H*STATE*H
        r2 = pick_pauli(STATE)
        STATE = r2[0]

        STATE = X*STATE*X
        r3 = pick_pauli(STATE)
        STATE = r3[0]
        
        rf = r1[1]*r2[1]*r3[1]
        pf = r1[2]*r2[2]*r3[2]
        
        p_hat = (rf/pf)*(STATE*Z).trace()
        results.append(p_hat)

    avg = sum(results)/samples
    print(np.asscalar(avg))

 '''
    local_state = kron(states[0])
    eiC = np.asmatrix(expm(complex(0,1)*gamma*kron([Z,Z,Z])))
    decomp = pick_pauli(eiC*local_state*np.conj(eiC))
    states[1] *= decomp[1]
    states[2] *= decomp[2]
    return [decomp[0], states[1], states[2]]
    '''

'''
def init_eqn_select2(n, d, d_constraint):
    # init random equation selecter
    eqn_select = []

    all_vars = True
    for i in range(0,n):
        # haven't used all variables yet
        if d_constraint[i] == 0:
            all_vars = False
            eqn_select.append(i)

    # create a list with all variables that haven't been used yet
    if not all_vars: 
        if len(eqn_select) < 3:
            to_pick = []
            for i in range (0,n):
                to_pick.append(i)
            
            for i in range(0,len(eqn_select)):
                to_pick.remove(eqn_select[i])
            
            while len(eqn_select) < 3:
                to_add = to_pick[random.randint(0,len(to_pick)-1)]
                eqn_select.append(to_add)
                to_pick.remove(to_add)
    else: 
        for i in range(0,n):
            # if we haven't used d of this variable, add it to the list of potential eqns to be picked
            if d_constraint[i] < d:
                eqn_select.append(i)
    return eqn_select

 given n (num of vars), d (max eqs for a single var), g (num of equations), create a system of linear equations that uses exactly n vars in g eqns with NO exact solutions
def create_eqn_list(n, d, f):
    equations = []

    if f < n/3:
        print('ERROR too few equations to use all variables!')
        sys.exit(1)

    if 3*f > n*d:
        print('ERROR too many constraints, or too few equations, or too few variables')
        sys.exit(1)

    # only make f - 1 equations for degeneracy later
    f = 1
    if g > 1:
        f = g - 1

    d_constraint = [0]*n
    #print('d_constra = ' + str(d_constraint) + '\n')

    # loop over equations left to create 
    while f > 0:
        # create init eqn selecter [1,2,...,n]
        eqn_select = init_eqn_select(n, d, d_constraint)
        if(len(eqn_select) < 3): 
            print('ERROR too many constraints (d is too small)')
            print('d_constraint = ' + str(d_constraint))
            sys.exit(1)

        #print('eqn start = ' + str(eqn_select))
        local_eqn = []

        for i in range(0,3):
            s = random.randint(0,len(eqn_select)-1)
            var = eqn_select[s]
            local_eqn.append(var)
            d_constraint[var] += 1
            eqn_select.remove(var)

        local_eqn.sort()
        # pick solution
        local_eqn.append(random.randint(0,1))

        #print('local_eqn = ' + str(local_eqn))
        #print('d_constra = ' + str(d_constraint))
        #print('')
        equations.append(local_eqn)
        f = f - 1

    # make the equation set degenerate so we dont have exact solutions (is there a better way to do this?)
    if g > 1:
        opposite = 0
        if equations[0][3] == 0:
            opposite = 1
        degen_eqn = [equations[0][0],equations[0][1],equations[0][2],opposite]
        equations.append(degen_eqn)
    return equations
'''
